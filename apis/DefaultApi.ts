/* tslint:disable */
/* eslint-disable */
/**
 * QuePasa RAG SaaS API
 * API for RAG retrieval, managing documents, files, and related operations including Telegram integration.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AnswerDetail,
  BatchStatus,
  ChunksDetail,
  CreatedBatchStatus,
  Document,
  DocumentDetail,
  DocumentNotFound,
  OperationFailedStatus,
  RetrieveAnswerRequest,
  SetupTelegramRequest,
  TelegramStatus,
} from '../models/index';
import {
    AnswerDetailFromJSON,
    AnswerDetailToJSON,
    BatchStatusFromJSON,
    BatchStatusToJSON,
    ChunksDetailFromJSON,
    ChunksDetailToJSON,
    CreatedBatchStatusFromJSON,
    CreatedBatchStatusToJSON,
    DocumentFromJSON,
    DocumentToJSON,
    DocumentDetailFromJSON,
    DocumentDetailToJSON,
    DocumentNotFoundFromJSON,
    DocumentNotFoundToJSON,
    OperationFailedStatusFromJSON,
    OperationFailedStatusToJSON,
    RetrieveAnswerRequestFromJSON,
    RetrieveAnswerRequestToJSON,
    SetupTelegramRequestFromJSON,
    SetupTelegramRequestToJSON,
    TelegramStatusFromJSON,
    TelegramStatusToJSON,
} from '../models/index';

export interface GetBatchStatusRequest {
    id: string;
}

export interface GetDocumentRequest {
    domain: string;
    id: string;
}

export interface ListDocumentsRequest {
    domain: string;
}

export interface RemoveDocumentRequest {
    domain: string;
    id: string;
}

export interface ReplaceDocumentsRequest {
    domain: string;
    document: Array<Document>;
}

export interface ResetDocumentsRequest {
    domain: string;
}

export interface RetrieveAnswerOperationRequest {
    retrieveAnswerRequest: RetrieveAnswerRequest;
}

export interface RetrieveChunksRequest {
    retrieveAnswerRequest: RetrieveAnswerRequest;
}

export interface SetupTelegramOperationRequest {
    setupTelegramRequest: SetupTelegramRequest;
}

export interface UpsertDocumentsRequest {
    domain: string;
    document: Array<Document>;
}

export interface UpsertFilesRequest {
    domain: string;
    file: Blob;
    language?: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Retrieve the status of a batch using its batch ID.
     * Get batch status
     */
    async getBatchStatusRaw(requestParameters: GetBatchStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchStatus>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getBatchStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/batches/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchStatusFromJSON(jsonValue));
    }

    /**
     * Retrieve the status of a batch using its batch ID.
     * Get batch status
     */
    async getBatchStatus(requestParameters: GetBatchStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatus> {
        const response = await this.getBatchStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details of a document by its domain and ID.
     * Get document details
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentDetail>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling getDocument().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getDocument().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}/{id}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentDetailFromJSON(jsonValue));
    }

    /**
     * Retrieve details of a document by its domain and ID.
     * Get document details
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentDetail> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all document IDs in the specified domain.
     * List documents
     */
    async listDocumentsRaw(requestParameters: ListDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling listDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * List all document IDs in the specified domain.
     * List documents
     */
    async listDocuments(requestParameters: ListDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.listDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a specific document by its domain and ID.
     * Remove document
     */
    async removeDocumentRaw(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling removeDocument().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling removeDocument().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}/{id}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Remove a specific document by its domain and ID.
     * Remove document
     */
    async removeDocument(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.removeDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace all documents in the specified domain with the provided documents.
     * Replace documents
     */
    async replaceDocumentsRaw(requestParameters: ReplaceDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling replaceDocuments().'
            );
        }

        if (requestParameters['document'] == null) {
            throw new runtime.RequiredError(
                'document',
                'Required parameter "document" was null or undefined when calling replaceDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['document']!.map(DocumentToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Replace all documents in the specified domain with the provided documents.
     * Replace documents
     */
    async replaceDocuments(requestParameters: ReplaceDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.replaceDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove all documents from the specified domain.
     * Reset documents
     */
    async resetDocumentsRaw(requestParameters: ResetDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling resetDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Remove all documents from the specified domain.
     * Reset documents
     */
    async resetDocuments(requestParameters: ResetDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.resetDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint allows you to generate an answer based on your data.
     * Retrieve answers or search data
     */
    async retrieveAnswerRaw(requestParameters: RetrieveAnswerOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnswerDetail>> {
        if (requestParameters['retrieveAnswerRequest'] == null) {
            throw new runtime.RequiredError(
                'retrieveAnswerRequest',
                'Required parameter "retrieveAnswerRequest" was null or undefined when calling retrieveAnswer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/retrieve/answer`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RetrieveAnswerRequestToJSON(requestParameters['retrieveAnswerRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnswerDetailFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to generate an answer based on your data.
     * Retrieve answers or search data
     */
    async retrieveAnswer(requestParameters: RetrieveAnswerOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnswerDetail> {
        const response = await this.retrieveAnswerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint allows you to perform a search on your data.
     * Retrieve answers or search data
     */
    async retrieveChunksRaw(requestParameters: RetrieveChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunksDetail>> {
        if (requestParameters['retrieveAnswerRequest'] == null) {
            throw new runtime.RequiredError(
                'retrieveAnswerRequest',
                'Required parameter "retrieveAnswerRequest" was null or undefined when calling retrieveChunks().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/retrieve/chunks`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RetrieveAnswerRequestToJSON(requestParameters['retrieveAnswerRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunksDetailFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to perform a search on your data.
     * Retrieve answers or search data
     */
    async retrieveChunks(requestParameters: RetrieveChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChunksDetail> {
        const response = await this.retrieveChunksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Configure Telegram for notifications or integrations.
     * Setup Telegram integration
     */
    async setupTelegramRaw(requestParameters: SetupTelegramOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TelegramStatus>> {
        if (requestParameters['setupTelegramRequest'] == null) {
            throw new runtime.RequiredError(
                'setupTelegramRequest',
                'Required parameter "setupTelegramRequest" was null or undefined when calling setupTelegram().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/telegram`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SetupTelegramRequestToJSON(requestParameters['setupTelegramRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TelegramStatusFromJSON(jsonValue));
    }

    /**
     * Configure Telegram for notifications or integrations.
     * Setup Telegram integration
     */
    async setupTelegram(requestParameters: SetupTelegramOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TelegramStatus> {
        const response = await this.setupTelegramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert new documents or update existing ones based on the ID.
     * Upsert documents
     */
    async upsertDocumentsRaw(requestParameters: UpsertDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling upsertDocuments().'
            );
        }

        if (requestParameters['document'] == null) {
            throw new runtime.RequiredError(
                'document',
                'Required parameter "document" was null or undefined when calling upsertDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['document']!.map(DocumentToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Insert new documents or update existing ones based on the ID.
     * Upsert documents
     */
    async upsertDocuments(requestParameters: UpsertDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.upsertDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload and upsert files into the document system.
     * Upsert files
     */
    async upsertFilesRaw(requestParameters: UpsertFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling upsertFiles().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling upsertFiles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['language'] != null) {
            formParams.append('language', requestParameters['language'] as any);
        }

        const response = await this.request({
            path: `/upload/data/files/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Upload and upsert files into the document system.
     * Upsert files
     */
    async upsertFiles(requestParameters: UpsertFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.upsertFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
