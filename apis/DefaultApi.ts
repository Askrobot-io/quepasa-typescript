/* tslint:disable */
/* eslint-disable */
/**
 * QuePasa RAG SaaS API
 * API for RAG retrieval, managing documents, files, and related operations including Telegram integration.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AnswerDetail,
  AnswerDetailData,
  BatchStatus,
  BatchStatusData,
  ChunksDetail,
  ChunksDetailDataInner,
  CreatedBatchStatus,
  Document,
  DocumentDetail,
  DocumentDetailData,
  DocumentNotFound,
  DomainDetail,
  DomainDetailData,
  DomainListDetail,
  OperationFailedStatus,
  RetrieveAnswerRequest,
  RetrieveChunksRequest,
  RetrieveWikiRequest,
  SetupTelegramRequest,
  TelegramStatus,
} from '../models/index';
import {
    AnswerDetailFromJSON,
    AnswerDetailToJSON,
    BatchStatusFromJSON,
    BatchStatusToJSON,
    ChunksDetailFromJSON,
    ChunksDetailToJSON,
    CreatedBatchStatusFromJSON,
    CreatedBatchStatusToJSON,
    DocumentFromJSON,
    DocumentToJSON,
    DocumentDetailFromJSON,
    DocumentDetailToJSON,
    DocumentNotFoundFromJSON,
    DocumentNotFoundToJSON,
    DomainDetailFromJSON,
    DomainDetailToJSON,
    DomainListDetailFromJSON,
    DomainListDetailToJSON,
    OperationFailedStatusFromJSON,
    OperationFailedStatusToJSON,
    RetrieveAnswerRequestFromJSON,
    RetrieveAnswerRequestToJSON,
    RetrieveChunksRequestFromJSON,
    RetrieveChunksRequestToJSON,
    RetrieveWikiRequestFromJSON,
    RetrieveWikiRequestToJSON,
    SetupTelegramRequestFromJSON,
    SetupTelegramRequestToJSON,
    TelegramStatusFromJSON,
    TelegramStatusToJSON,
} from '../models/index';

export interface GetBatchStatusRequest {
    id: string;
}

export interface GetDocumentRequest {
    domain: string;
    id: string;
}

export interface ListDocumentsRequest {
    domain: string;
}

export interface RemoveDocumentRequest {
    domain: string;
    id: string;
}

export interface ReplaceDocumentsRequest {
    domain: string;
    documents: Array<Document>;
}

export interface RemoveDomain {
    domain: string;
}

export interface SetupTelegramOperationRequest {
    setupTelegramRequest: SetupTelegramRequest;
}

export interface UpsertDocumentsRequest {
    domain: string;
    documents: Array<Document>;
}

export interface UpsertFileRequest {
    domain: string;
    file: Blob;
    language?: string;
}

export interface UpsertUrlsRequest {
    domain: string;
    urls: Array<string>;
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Retrieve the status of a batch using its batch ID.
     * Get batch status
     */
    async getBatchStatusRaw(requestParameters: GetBatchStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchStatus>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getBatchStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/batches/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchStatusFromJSON(jsonValue));
    }

    /**
     * Retrieve the status of a batch using its batch ID.
     * Get batch status
     */
    async getBatchStatus(requestParameters: GetBatchStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatus> {
        const response = await this.getBatchStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Wait for status of a batch
     */
    async waitForBatch(createdBatchStatus: CreatedBatchStatus, intervalValue:number = 10000, timeoutValue: number = 600000): Promise<BatchStatus> {
        return new Promise((resolve, reject) => {
            let interval = setInterval(async () => {
                try {
                    let result = await this.getBatchStatus({ id: createdBatchStatus.data.batchId + "" });
                    if (result.status === "Batch state: done") {
                        clearTimeout(timeout);
                        clearInterval(interval);
                        resolve(result); // Resolve the promise with the result when batch is done
                    }
                } catch (error) {
                    clearTimeout(timeout);
                    clearInterval(interval);
                    reject({
                        error: error
                    }); // Reject the promise if an error occurs
                }
            }, intervalValue);

            let timeout = setTimeout(async () => {
                clearTimeout(timeout);
                clearInterval(interval);
                reject({
                    error: "waitForBatch timeout",
                    batchId: createdBatchStatus.data.batchId + "",
                });
            }, timeoutValue);
        });
    }

    /**
     * Retrieve details of a document by its domain and ID.
     * Get document details
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentDetail>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling getDocument().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getDocument().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}/{id}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentDetailFromJSON(jsonValue));
    }

    /**
     * Retrieve details of a document by its domain and ID.
     * Get document details
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentDetailData> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        let result = await response.value();
        if ( result['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return result['data']
    }

    /**
     * List all document IDs in the specified domain.
     * List documents
     */
    async listDocumentsRaw(requestParameters: ListDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainDetail>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling listDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainDetailFromJSON(jsonValue));
    }

    /**
     * List all document IDs in the specified domain.
     * List documents
     */
    async listDocuments(requestParameters: ListDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainDetailData> {
        const response = await this.listDocumentsRaw(requestParameters, initOverrides);
        let result = await response.value();
        if ( result['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return result['data'];
    }

    /**
     * List all document IDs in all available domains.
     * List all documents
     */
    async listAllDocumentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainListDetail>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainListDetailFromJSON(jsonValue));
    }

    /**
     * List all document IDs in all available domains.
     * List all documents
     */
    async listAllDocuments(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DomainDetailData>> {
        const response = await this.listAllDocumentsRaw(initOverrides);
        let result = await response.value();
        if ( result['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return result['data'];
    }

    /**
     * Remove a specific document by its domain and ID.
     * Remove document
     */
    async removeDocumentRaw(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling removeDocument().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling removeDocument().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}/{id}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Remove a specific document by its domain and ID.
     * Remove document, returns batch id to track operation status.
     */
    async removeDocumentAsync(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.removeDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a specific document by its domain and ID.
     * Remove document, returns list of removed document ids for requested domain.
     */
    async removeDocumentAndWait(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        const createdBatchStatus = await this.removeDocumentAsync(requestParameters, initOverrides);
        const batchStatus = await this.waitForBatch(createdBatchStatus);
        if ( batchStatus['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return batchStatus['data'];
    }

    /**
     * Remove a specific document by its domain and ID.
     * Remove document, returns list of removed document ids for requested domain.
     * (alias to removeDocumentAndWait)
     */
    async removeDocument(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.removeDocumentAndWait(requestParameters, initOverrides);
    }

    /**
     * Remove a specific file by its domain and ID.
     * Remove file, returns list of removed document ids for requested domain.
     * (alias to removeDocument)
     */
    async removeFile(requestParameters: RemoveDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.removeDocument(requestParameters, initOverrides);
    }

    /**
     * Replace all documents in the specified domain with the provided documents.
     * Replace documents
     */
    async replaceDocumentsRaw(requestParameters: ReplaceDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling replaceDocuments().'
            );
        }

        if (requestParameters['documents'] == null) {
            throw new runtime.RequiredError(
                'documents',
                'Required parameter "document" was null or undefined when calling replaceDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['documents']!.map(DocumentToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Replace all documents in the specified domain with the provided documents.
     * Replace documents, returns batch id to track operation status.
     */
    async replaceDocumentsAsync(requestParameters: ReplaceDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.replaceDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace all documents in the specified domain with the provided documents.
     * Replace documents, returns list of replaced document ids for requested domain.
     */
    async replaceDocumentsAndWait(requestParameters: ReplaceDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        const createdBatchStatus = await this.replaceDocumentsAsync(requestParameters, initOverrides);
        const batchStatus = await this.waitForBatch(createdBatchStatus);
        if ( batchStatus['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return batchStatus['data'];
    }

    /**
     * Replace all documents in the specified domain with the provided documents.
     * Replace documents, returns list of replaced document ids for requested domain.
     * (alias to replaceDocumentsAndWait)
     */
    async replaceDocuments(requestParameters: ReplaceDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.replaceDocumentsAndWait(requestParameters, initOverrides);
    }

    /**
     * Remove all documents from the specified domain.
     * Remove domain
     */
    async removeDomainRaw(requestParameters: RemoveDomain, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling removeDomain().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Remove all documents from the specified domain.
     * Remove domain, returns batch id to track operation status.
     */
    async removeDomainAsync(requestParameters: RemoveDomain, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.removeDomainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove all documents from the specified domain.
     * Remove domain, returns list of removed document ids for requested domain.
     */
    async removeDomainAndWait(requestParameters: RemoveDomain, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        const createdBatchStatus = await this.removeDomainAsync(requestParameters, initOverrides);
        const batchStatus = await this.waitForBatch(createdBatchStatus);
        if ( batchStatus['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return batchStatus['data'];
    }

    /**
     * Remove all documents from the specified domain.
     * Remove domain, returns list of removed document ids for requested domain.
     * (alias to removeDomainAndWait)
     */
    async removeDomain(requestParameters: RemoveDomain, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.removeDomainAndWait(requestParameters, initOverrides);
    }

    /**
     * This endpoint allows you to generate an answer based on your data.
     * Retrieve answers or search data
     */
    async retrieveAnswerRaw(requestParameters: RetrieveAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnswerDetail>> {
        if (requestParameters['question'] == null) {
            throw new runtime.RequiredError(
                'question',
                'Required parameter "question" was null or undefined when calling retrieveAnswer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/retrieve/answer`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RetrieveAnswerRequestToJSON(requestParameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnswerDetailFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to generate an answer based on your data.
     * Retrieve answers or search data
     */
    async retrieveAnswer(requestParameters: RetrieveAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnswerDetailData> {
        const response = await this.retrieveAnswerRaw(requestParameters, initOverrides);
        let result = await response.value();
        if ( result['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return result['data'];
    }

    /**
     * Generate a wiki page based on your data.
     * Retrieve wiki
     */
    async retrieveWikiRaw(requestParameters: RetrieveWikiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnswerDetail>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        const response = await this.request({
            path: "/retrieve/wiki",
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RetrieveWikiRequestToJSON(requestParameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnswerDetailFromJSON(jsonValue));
    }

    /**
     * Generate a wiki page based on your data.
     * Retrieve wiki
     */
    async retrieveWiki(requestParameters: RetrieveWikiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnswerDetailData> {
        const response =await this.retrieveWikiRaw(requestParameters, initOverrides);
        let result = await response.value();
        if ( result['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return result['data'];
    }

    /**
     * This endpoint allows you to perform a search on your data.
     * Retrieve answers or search data
     */
    async retrieveChunksRaw(requestParameters: RetrieveChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunksDetail>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/retrieve/chunks`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RetrieveChunksRequestToJSON(requestParameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunksDetailFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to perform a search on your data.
     * Retrieve answers or search data
     */
    async retrieveChunks(requestParameters: RetrieveChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ChunksDetailDataInner>> {
        const response = await this.retrieveChunksRaw(requestParameters, initOverrides);
        let result = await response.value();
        if ( result['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return result['data'];
    }

    /**
     * Configure Telegram for notifications or integrations.
     * Setup Telegram integration
     */
    async setupTelegramRaw(requestParameters: SetupTelegramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TelegramStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/telegram`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SetupTelegramRequestToJSON(requestParameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TelegramStatusFromJSON(jsonValue));
    }

    /**
     * Configure Telegram for notifications or integrations.
     * Setup Telegram integration
     */
    async setupTelegram(requestParameters: SetupTelegramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TelegramStatus> {
        const response = await this.setupTelegramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert new documents or update existing ones based on the ID.
     * Upsert documents
     */
    async upsertDocumentsRaw(requestParameters: UpsertDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling upsertDocuments().'
            );
        }

        if (requestParameters['documents'] == null) {
            throw new runtime.RequiredError(
                'documents',
                'Required parameter "document" was null or undefined when calling upsertDocuments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/documents/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['documents']!.map(DocumentToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Insert new documents or update existing ones based on the ID.
     * Upsert documents, returns batch id to track operation status.
     */
    async upsertDocumentsAsync(requestParameters: UpsertDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.upsertDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert new documents or update existing ones based on the ID.
     * Upsert documents, returns list of upserted document ids for requested domain.
     */
    async upsertDocumentsAndWait(requestParameters: UpsertDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        const createdBatchStatus = await this.upsertDocumentsAsync(requestParameters, initOverrides);
        const batchStatus = await this.waitForBatch(createdBatchStatus);
        if ( batchStatus['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return batchStatus['data'];
    }

    /**
     * Insert new documents or update existing ones based on the ID.
     * Upsert documents, returns list of upserted document ids for requested domain.
     * (alias to upsertDocumentsAndWait)
     */
    async upsertDocuments(requestParameters: UpsertDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.upsertDocumentsAndWait(requestParameters, initOverrides);
    }

    /**
     * Upload and upsert file into the document system.
     * Upsert file
     */
    async upsertFileRaw(requestParameters: UpsertFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling upsertFiles().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling upsertFiles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['language'] != null) {
            formParams.append('language', requestParameters['language'] as any);
        }

        const response = await this.request({
            path: `/upload/data/files/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Upload and upsert file into the document system.
     * Upsert file, returns batch id to track operation status.
     */
    async upsertFileAsync(requestParameters: UpsertFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.upsertFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload and upsert file into the document system.
     * Upsert file, returns list of upserted file ids for requested domain.
     */
    async upsertFileAndWait(requestParameters: UpsertFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        const createdBatchStatus = await this.upsertFileAsync(requestParameters, initOverrides);
        const batchStatus = await this.waitForBatch(createdBatchStatus);
        if ( batchStatus['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return batchStatus['data'];
    }

    /**
     * Upload and upsert file into the document system.
     * Upsert file, returns list of upserted file ids for requested domain.
     * (alias to upsertFileAndWait)
     */
    async upsertFile(requestParameters: UpsertFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.upsertFileAndWait(requestParameters, initOverrides);
    }

    /**
     * Upload and upsert urls into the document system.  Supported formats: txt, md, html, pdf, doc, docx, xls, xlsx, ppt, pptx, Youtube transcripts (form Youtube videos)
     * Upsert urls
     */
    async upsertUrlsRaw(requestParameters: UpsertUrlsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatedBatchStatus>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling upsertUrls().'
            );
        }

        if (requestParameters['urls'] == null) {
            throw new runtime.RequiredError(
                'urls',
                'Required parameter "urls" was null or undefined when calling upsertUrls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/upload/data/urls/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters['domain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['urls'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatedBatchStatusFromJSON(jsonValue));
    }

    /**
     * Upsert urls into the document system.  Supported formats: txt, md, html, pdf, doc, docx, xls, xlsx, ppt, pptx, Youtube transcripts (form Youtube videos)
     * Upsert urls, returns batch id to track operation status.
     */
    async upsertUrlsAsync(requestParameters: UpsertUrlsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatedBatchStatus> {
        const response = await this.upsertUrlsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert urls into the document system.  Supported formats: txt, md, html, pdf, doc, docx, xls, xlsx, ppt, pptx, Youtube transcripts (form Youtube videos)
     * Upsert urls, returns list of upserted file ids for requested domain.
     */
    async upsertUrlsAndWait(requestParameters: UpsertUrlsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        const createdBatchStatus = await this.upsertUrlsAsync(requestParameters, initOverrides);
        const batchStatus = await this.waitForBatch(createdBatchStatus);
        if ( batchStatus['data'] == null ) {
            throw new Error('Response returned an "data" that was null or undefined.');
        }
        return batchStatus['data'];
    }

    /**
     * Upsert urls into the document system.  Supported formats: txt, md, html, pdf, doc, docx, xls, xlsx, ppt, pptx, Youtube transcripts (form Youtube videos)
     * Upsert urls, returns list of upserted file ids for requested domain.
     * (alias to upsertUrlsAndWait)
     */
    async upsertUrls(requestParameters: UpsertUrlsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchStatusData> {
        return await this.upsertUrlsAndWait(requestParameters, initOverrides);
    }
}
